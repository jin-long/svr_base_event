!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CQ	/home/xsw/svr_base_event/project/threads.h	/^typedef struct conn_queue CQ;$/;"	t	typeref:struct:conn_queue
CQ_ITEM	/home/xsw/svr_base_event/project/threads.h	/^typedef struct conn_queue_item CQ_ITEM;$/;"	t	typeref:struct:conn_queue_item
EXTSTORE_THREAD_STATS_FIELDS	/home/xsw/svr_base_event/project/net_model.h	169;"	d
LIBEVENT_THREAD	/home/xsw/svr_base_event/project/net_model.h	/^} LIBEVENT_THREAD;$/;"	t	typeref:struct:__anon1
MAXPATHLEN	/home/xsw/svr_base_event/project/net_model.c	18;"	d	file:
MAX_LINE	/home/xsw/svr_base_event/project/net_svr.c	17;"	d	file:
MAX_NUMBER_OF_SLAB_CLASSES	/home/xsw/svr_base_event/project/net_model.h	24;"	d
MAX_VERBOSITY_LEVEL	/home/xsw/svr_base_event/project/net_model.h	17;"	d
PAUSE_ALL_THREADS	/home/xsw/svr_base_event/project/net_model.h	/^    PAUSE_ALL_THREADS,$/;"	e	enum:pause_thread_types
PAUSE_WORKER_THREADS	/home/xsw/svr_base_event/project/net_model.h	/^    PAUSE_WORKER_THREADS = 0,$/;"	e	enum:pause_thread_types
POWER_LARGEST	/home/xsw/svr_base_event/project/net_model.h	21;"	d
POWER_SMALLEST	/home/xsw/svr_base_event/project/net_model.h	20;"	d
READ_DATA_RECEIVED	/home/xsw/svr_base_event/project/net_model.c	/^    READ_DATA_RECEIVED,$/;"	e	enum:try_read_result	file:
READ_ERROR	/home/xsw/svr_base_event/project/net_model.c	/^    READ_ERROR,            \/** an error occurred (on the socket) (or client closed connection) *\/$/;"	e	enum:try_read_result	file:
READ_MEMORY_ERROR	/home/xsw/svr_base_event/project/net_model.c	/^    READ_MEMORY_ERROR      \/** failed to allocate more memory *\/$/;"	e	enum:try_read_result	file:
READ_NO_DATA_RECEIVED	/home/xsw/svr_base_event/project/net_model.c	/^    READ_NO_DATA_RECEIVED,$/;"	e	enum:try_read_result	file:
RESUME_ALL_THREADS	/home/xsw/svr_base_event/project/net_model.h	/^    RESUME_ALL_THREADS,$/;"	e	enum:pause_thread_types
RESUME_WORKER_THREADS	/home/xsw/svr_base_event/project/net_model.h	/^    RESUME_WORKER_THREADS$/;"	e	enum:pause_thread_types
TAIL_REPAIR_TIME_DEFAULT	/home/xsw/svr_base_event/project/net_model.c	32;"	d	file:
THREAD_STATS_FIELDS	/home/xsw/svr_base_event/project/net_model.h	149;"	d
X	/home/xsw/svr_base_event/project/net_model.h	144;"	d
X	/home/xsw/svr_base_event/project/net_model.h	146;"	d
X	/home/xsw/svr_base_event/project/net_model.h	183;"	d
X	/home/xsw/svr_base_event/project/net_model.h	188;"	d
__anon1::base	/home/xsw/svr_base_event/project/net_model.h	/^    struct event_base *base;    \/* libevent handle this thread uses *\/$/;"	m	struct:__anon1	typeref:struct:__anon1::event_base	access:public
__anon1::io_cache	/home/xsw/svr_base_event/project/net_model.h	/^    cache_t *io_cache;          \/* IO objects *\/$/;"	m	struct:__anon1	access:public
__anon1::l	/home/xsw/svr_base_event/project/net_model.h	/^    logger *l;                  \/* logger buffer *\/$/;"	m	struct:__anon1	access:public
__anon1::lru_bump_buf	/home/xsw/svr_base_event/project/net_model.h	/^    void *lru_bump_buf;         \/* async LRU bump buffer *\/$/;"	m	struct:__anon1	access:public
__anon1::new_conn_queue	/home/xsw/svr_base_event/project/net_model.h	/^    struct conn_queue *new_conn_queue; \/* queue of new connections to handle *\/$/;"	m	struct:__anon1	typeref:struct:__anon1::conn_queue	access:public
__anon1::notify_event	/home/xsw/svr_base_event/project/net_model.h	/^    struct event notify_event;  \/* listen event for notify pipe *\/$/;"	m	struct:__anon1	typeref:struct:__anon1::event	access:public
__anon1::notify_receive_fd	/home/xsw/svr_base_event/project/net_model.h	/^    int notify_receive_fd;      \/* receiving end of notify pipe *\/$/;"	m	struct:__anon1	access:public
__anon1::notify_send_fd	/home/xsw/svr_base_event/project/net_model.h	/^    int notify_send_fd;         \/* sending end of notify pipe *\/$/;"	m	struct:__anon1	access:public
__anon1::stats	/home/xsw/svr_base_event/project/net_model.h	/^    struct thread_stats stats;  \/* Stats generated by this thread *\/$/;"	m	struct:__anon1	typeref:struct:__anon1::thread_stats	access:public
__anon1::storage	/home/xsw/svr_base_event/project/net_model.h	/^    void *storage;              \/* data object for storage system *\/$/;"	m	struct:__anon1	access:public
__anon1::suffix_cache	/home/xsw/svr_base_event/project/net_model.h	/^    cache_t *suffix_cache;      \/* suffix cache *\/$/;"	m	struct:__anon1	access:public
__anon1::thread_id	/home/xsw/svr_base_event/project/net_model.h	/^    pthread_t thread_id;        \/* unique ID of this thread *\/$/;"	m	struct:__anon1	access:public
accept_new_conns	/home/xsw/svr_base_event/project/threads.c	/^void accept_new_conns(const bool do_accept) {$/;"	f	signature:(const bool do_accept)
access	/home/xsw/svr_base_event/project/net_model.h	/^    int access;  \/* access mask (a la chmod) for unix domain socket *\/$/;"	m	struct:settings	access:public
alloc_fd_state	/home/xsw/svr_base_event/project/net_svr.c	/^struct fd_state * alloc_fd_state(struct event_base *base, evutil_socket_t fd)  $/;"	f	signature:(struct event_base *base, evutil_socket_t fd)
allow_new_conns	/home/xsw/svr_base_event/project/net_model.c	/^static volatile bool allow_new_conns = true;$/;"	v	file:
ascii_prot	/home/xsw/svr_base_event/project/net_model.h	/^    ascii_prot = 3, \/* arbitrary value. *\/$/;"	e	enum:protocol
authenticated	/home/xsw/svr_base_event/project/net_model.h	/^    bool authenticated;$/;"	m	struct:conn	access:public
backlog	/home/xsw/svr_base_event/project/net_model.h	/^    int backlog;$/;"	m	struct:settings	access:public
base	/home/xsw/svr_base_event/project/net_model.h	/^    struct event_base *base;    \/* libevent handle this thread uses *\/$/;"	m	struct:__anon1	typeref:struct:__anon1::event_base	access:public
binary_header	/home/xsw/svr_base_event/project/net_model.h	/^    protocol_binary_request_header binary_header;$/;"	m	struct:conn	access:public
binary_prot	/home/xsw/svr_base_event/project/net_model.h	/^    binary_prot,$/;"	e	enum:protocol
binding_protocol	/home/xsw/svr_base_event/project/net_model.h	/^    enum protocol binding_protocol;$/;"	m	struct:settings	typeref:enum:settings::protocol	access:public
buffer	/home/xsw/svr_base_event/project/net_model.h	/^        char *buffer;$/;"	m	struct:conn::__anon2	access:public
buffer	/home/xsw/svr_base_event/project/net_svr.c	/^    char buffer[MAX_LINE];  $/;"	m	struct:fd_state	file:	access:public
buffer_used	/home/xsw/svr_base_event/project/net_svr.c	/^    size_t buffer_used;  $/;"	m	struct:fd_state	file:	access:public
c	/home/xsw/svr_base_event/project/threads.h	/^    conn *c;$/;"	m	struct:conn_queue_item	access:public
cas	/home/xsw/svr_base_event/project/net_model.h	/^    uint64_t cas; \/* the cas to return *\/$/;"	m	struct:conn	access:public
chunk_size	/home/xsw/svr_base_event/project/net_model.h	/^    int chunk_size;$/;"	m	struct:settings	access:public
cmd	/home/xsw/svr_base_event/project/net_model.h	/^    short cmd; \/* current command being processed *\/$/;"	m	struct:conn	access:public
conn	/home/xsw/svr_base_event/project/net_model.h	/^struct conn {$/;"	s
conn::__anon2::buffer	/home/xsw/svr_base_event/project/net_model.h	/^        char *buffer;$/;"	m	struct:conn::__anon2	access:public
conn::__anon2::offset	/home/xsw/svr_base_event/project/net_model.h	/^        size_t offset;$/;"	m	struct:conn::__anon2	access:public
conn::__anon2::size	/home/xsw/svr_base_event/project/net_model.h	/^        size_t size;$/;"	m	struct:conn::__anon2	access:public
conn::authenticated	/home/xsw/svr_base_event/project/net_model.h	/^    bool authenticated;$/;"	m	struct:conn	access:public
conn::binary_header	/home/xsw/svr_base_event/project/net_model.h	/^    protocol_binary_request_header binary_header;$/;"	m	struct:conn	access:public
conn::cas	/home/xsw/svr_base_event/project/net_model.h	/^    uint64_t cas; \/* the cas to return *\/$/;"	m	struct:conn	access:public
conn::cmd	/home/xsw/svr_base_event/project/net_model.h	/^    short cmd; \/* current command being processed *\/$/;"	m	struct:conn	access:public
conn::ev_flags	/home/xsw/svr_base_event/project/net_model.h	/^    short  ev_flags;$/;"	m	struct:conn	access:public
conn::event	/home/xsw/svr_base_event/project/net_model.h	/^    struct event event;$/;"	m	struct:conn	typeref:struct:conn::event	access:public
conn::hdrbuf	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned char *hdrbuf; \/* udp packet headers *\/$/;"	m	struct:conn	access:public
conn::hdrsize	/home/xsw/svr_base_event/project/net_model.h	/^    int    hdrsize;   \/* number of headers' worth of space is allocated *\/$/;"	m	struct:conn	access:public
conn::icurr	/home/xsw/svr_base_event/project/net_model.h	/^    item   **icurr;$/;"	m	struct:conn	access:public
conn::ileft	/home/xsw/svr_base_event/project/net_model.h	/^    int    ileft;$/;"	m	struct:conn	access:public
conn::ilist	/home/xsw/svr_base_event/project/net_model.h	/^    item   **ilist;   \/* list of items to write out *\/$/;"	m	struct:conn	access:public
conn::io_queued	/home/xsw/svr_base_event/project/net_model.h	/^    bool io_queued; \/* FIXME: debugging flag *\/$/;"	m	struct:conn	access:public
conn::io_wrapleft	/home/xsw/svr_base_event/project/net_model.h	/^    int io_wrapleft;$/;"	m	struct:conn	access:public
conn::io_wraplist	/home/xsw/svr_base_event/project/net_model.h	/^    io_wrap *io_wraplist; \/* linked list of io_wraps *\/$/;"	m	struct:conn	access:public
conn::iov	/home/xsw/svr_base_event/project/net_model.h	/^    struct iovec *iov;$/;"	m	struct:conn	typeref:struct:conn::iovec	access:public
conn::iovsize	/home/xsw/svr_base_event/project/net_model.h	/^    int    iovsize;   \/* number of elements allocated in iov[] *\/$/;"	m	struct:conn	access:public
conn::iovused	/home/xsw/svr_base_event/project/net_model.h	/^    int    iovused;   \/* number of elements used in iov[] *\/$/;"	m	struct:conn	access:public
conn::isize	/home/xsw/svr_base_event/project/net_model.h	/^    int    isize;$/;"	m	struct:conn	access:public
conn::item	/home/xsw/svr_base_event/project/net_model.h	/^    void   *item;     \/* for commands set\/add\/replace  *\/$/;"	m	struct:conn	access:public
conn::keylen	/home/xsw/svr_base_event/project/net_model.h	/^    int keylen;$/;"	m	struct:conn	access:public
conn::last_cmd_time	/home/xsw/svr_base_event/project/net_model.h	/^    rel_time_t last_cmd_time;$/;"	m	struct:conn	access:public
conn::msgbytes	/home/xsw/svr_base_event/project/net_model.h	/^    int    msgbytes;  \/* number of bytes in current msg *\/$/;"	m	struct:conn	access:public
conn::msgcurr	/home/xsw/svr_base_event/project/net_model.h	/^    int    msgcurr;   \/* element in msglist[] being transmitted now *\/$/;"	m	struct:conn	access:public
conn::msglist	/home/xsw/svr_base_event/project/net_model.h	/^    struct msghdr *msglist;$/;"	m	struct:conn	typeref:struct:conn::msghdr	access:public
conn::msgsize	/home/xsw/svr_base_event/project/net_model.h	/^    int    msgsize;   \/* number of elements allocated in msglist[] *\/$/;"	m	struct:conn	access:public
conn::msgused	/home/xsw/svr_base_event/project/net_model.h	/^    int    msgused;   \/* number of elements used in msglist[] *\/$/;"	m	struct:conn	access:public
conn::next	/home/xsw/svr_base_event/project/net_model.h	/^    conn   *next;     \/* Used for generating a list of conn structures *\/$/;"	m	struct:conn	access:public
conn::noreply	/home/xsw/svr_base_event/project/net_model.h	/^    bool   noreply;   \/* True if the reply should not be sent. *\/$/;"	m	struct:conn	access:public
conn::opaque	/home/xsw/svr_base_event/project/net_model.h	/^    int opaque;$/;"	m	struct:conn	access:public
conn::protocol	/home/xsw/svr_base_event/project/net_model.h	/^    enum protocol protocol;   \/* which protocol this connection speaks *\/$/;"	m	struct:conn	typeref:enum:conn::protocol	access:public
conn::rbuf	/home/xsw/svr_base_event/project/net_model.h	/^    char   *rbuf;   \/** buffer to read commands into *\/$/;"	m	struct:conn	access:public
conn::rbytes	/home/xsw/svr_base_event/project/net_model.h	/^    int    rbytes;  \/** how much data, starting from rcur, do we have unparsed *\/$/;"	m	struct:conn	access:public
conn::rcurr	/home/xsw/svr_base_event/project/net_model.h	/^    char   *rcurr;  \/** but if we parsed some already, this is where we stopped *\/$/;"	m	struct:conn	access:public
conn::recache_counter	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int recache_counter;$/;"	m	struct:conn	access:public
conn::request_addr	/home/xsw/svr_base_event/project/net_model.h	/^    struct sockaddr_in6 request_addr; \/* udp: Who sent the most recent request *\/$/;"	m	struct:conn	typeref:struct:conn::sockaddr_in6	access:public
conn::request_addr_size	/home/xsw/svr_base_event/project/net_model.h	/^    socklen_t request_addr_size;$/;"	m	struct:conn	access:public
conn::request_id	/home/xsw/svr_base_event/project/net_model.h	/^    int    request_id; \/* Incoming UDP request ID, if this is a UDP "connection" *\/$/;"	m	struct:conn	access:public
conn::ritem	/home/xsw/svr_base_event/project/net_model.h	/^    char   *ritem;  \/** when we read in an item's value, it goes here *\/$/;"	m	struct:conn	access:public
conn::rlbytes	/home/xsw/svr_base_event/project/net_model.h	/^    int    rlbytes;$/;"	m	struct:conn	access:public
conn::rsize	/home/xsw/svr_base_event/project/net_model.h	/^    int    rsize;   \/** total allocated size of rbuf *\/$/;"	m	struct:conn	access:public
conn::sasl_conn	/home/xsw/svr_base_event/project/net_model.h	/^    sasl_conn_t *sasl_conn;$/;"	m	struct:conn	access:public
conn::sasl_started	/home/xsw/svr_base_event/project/net_model.h	/^    bool sasl_started;$/;"	m	struct:conn	access:public
conn::sbytes	/home/xsw/svr_base_event/project/net_model.h	/^    int    sbytes;    \/* how many bytes to swallow *\/$/;"	m	struct:conn	access:public
conn::sfd	/home/xsw/svr_base_event/project/net_model.h	/^    int    sfd;$/;"	m	struct:conn	access:public
conn::state	/home/xsw/svr_base_event/project/net_model.h	/^    enum conn_states  state;$/;"	m	struct:conn	typeref:enum:conn::conn_states	access:public
conn::stats	/home/xsw/svr_base_event/project/net_model.h	/^    } stats;$/;"	m	struct:conn	typeref:struct:conn::__anon2	access:public
conn::substate	/home/xsw/svr_base_event/project/net_model.h	/^    enum bin_substates substate;$/;"	m	struct:conn	typeref:enum:conn::bin_substates	access:public
conn::suffixcurr	/home/xsw/svr_base_event/project/net_model.h	/^    char   **suffixcurr;$/;"	m	struct:conn	access:public
conn::suffixleft	/home/xsw/svr_base_event/project/net_model.h	/^    int    suffixleft;$/;"	m	struct:conn	access:public
conn::suffixlist	/home/xsw/svr_base_event/project/net_model.h	/^    char   **suffixlist;$/;"	m	struct:conn	access:public
conn::suffixsize	/home/xsw/svr_base_event/project/net_model.h	/^    int    suffixsize;$/;"	m	struct:conn	access:public
conn::thread	/home/xsw/svr_base_event/project/net_model.h	/^    LIBEVENT_THREAD *thread; \/* Pointer to the thread object serving this connection *\/$/;"	m	struct:conn	access:public
conn::transport	/home/xsw/svr_base_event/project/net_model.h	/^    enum network_transport transport; \/* what transport is used by this connection *\/$/;"	m	struct:conn	typeref:enum:conn::network_transport	access:public
conn::wbuf	/home/xsw/svr_base_event/project/net_model.h	/^    char   *wbuf;$/;"	m	struct:conn	access:public
conn::wbytes	/home/xsw/svr_base_event/project/net_model.h	/^    int    wbytes;$/;"	m	struct:conn	access:public
conn::wcurr	/home/xsw/svr_base_event/project/net_model.h	/^    char   *wcurr;$/;"	m	struct:conn	access:public
conn::which	/home/xsw/svr_base_event/project/net_model.h	/^    short  which;   \/** which events were just triggered *\/$/;"	m	struct:conn	access:public
conn::write_and_free	/home/xsw/svr_base_event/project/net_model.h	/^    void   *write_and_free; \/** free this memory after finishing writing *\/$/;"	m	struct:conn	access:public
conn::write_and_go	/home/xsw/svr_base_event/project/net_model.h	/^    enum conn_states  write_and_go;$/;"	m	struct:conn	typeref:enum:conn::conn_states	access:public
conn::wsize	/home/xsw/svr_base_event/project/net_model.h	/^    int    wsize;$/;"	m	struct:conn	access:public
conn_closed	/home/xsw/svr_base_event/project/net_model.h	/^    conn_closed,     \/**< connection is closed *\/$/;"	e	enum:conn_states
conn_closing	/home/xsw/svr_base_event/project/net_model.h	/^    conn_closing,    \/**< closing this connection *\/$/;"	e	enum:conn_states
conn_init	/home/xsw/svr_base_event/project/net_model.c	/^static void conn_init(void) {$/;"	f	file:	signature:(void)
conn_listening	/home/xsw/svr_base_event/project/net_model.h	/^    conn_listening,  \/**< the socket which listens for connections *\/$/;"	e	enum:conn_states
conn_max_state	/home/xsw/svr_base_event/project/net_model.h	/^    conn_max_state   \/**< Max state value (used for assertion) *\/$/;"	e	enum:conn_states
conn_mwrite	/home/xsw/svr_base_event/project/net_model.h	/^    conn_mwrite,     \/**< writing out many items sequentially *\/$/;"	e	enum:conn_states
conn_new	/home/xsw/svr_base_event/project/net_model.c	/^conn *conn_new(const int sfd, enum conn_states init_state,$/;"	f	signature:(const int sfd, enum conn_states init_state, const int event_flags, const int read_buffer_size, enum network_transport transport, struct event_base *base)
conn_new_cmd	/home/xsw/svr_base_event/project/net_model.h	/^    conn_new_cmd,    \/**< Prepare connection for next command *\/$/;"	e	enum:conn_states
conn_nread	/home/xsw/svr_base_event/project/net_model.h	/^    conn_nread,      \/**< reading in a fixed number of bytes *\/$/;"	e	enum:conn_states
conn_parse_cmd	/home/xsw/svr_base_event/project/net_model.h	/^    conn_parse_cmd,  \/**< try to parse a command from the input buffer *\/$/;"	e	enum:conn_states
conn_queue	/home/xsw/svr_base_event/project/threads.h	/^struct conn_queue {$/;"	s
conn_queue::head	/home/xsw/svr_base_event/project/threads.h	/^    CQ_ITEM *head;$/;"	m	struct:conn_queue	access:public
conn_queue::lock	/home/xsw/svr_base_event/project/threads.h	/^    pthread_mutex_t lock;$/;"	m	struct:conn_queue	access:public
conn_queue::tail	/home/xsw/svr_base_event/project/threads.h	/^    CQ_ITEM *tail;$/;"	m	struct:conn_queue	access:public
conn_queue_item	/home/xsw/svr_base_event/project/threads.h	/^struct conn_queue_item {$/;"	s
conn_queue_item::c	/home/xsw/svr_base_event/project/threads.h	/^    conn *c;$/;"	m	struct:conn_queue_item	access:public
conn_queue_item::event_flags	/home/xsw/svr_base_event/project/threads.h	/^    int               event_flags;$/;"	m	struct:conn_queue_item	access:public
conn_queue_item::init_state	/home/xsw/svr_base_event/project/threads.h	/^    enum conn_states  init_state;$/;"	m	struct:conn_queue_item	typeref:enum:conn_queue_item::conn_states	access:public
conn_queue_item::mode	/home/xsw/svr_base_event/project/threads.h	/^    enum conn_queue_item_modes mode;$/;"	m	struct:conn_queue_item	typeref:enum:conn_queue_item::conn_queue_item_modes	access:public
conn_queue_item::next	/home/xsw/svr_base_event/project/threads.h	/^    CQ_ITEM          *next;$/;"	m	struct:conn_queue_item	access:public
conn_queue_item::read_buffer_size	/home/xsw/svr_base_event/project/threads.h	/^    int               read_buffer_size;$/;"	m	struct:conn_queue_item	access:public
conn_queue_item::sfd	/home/xsw/svr_base_event/project/threads.h	/^    int               sfd;$/;"	m	struct:conn_queue_item	access:public
conn_queue_item::transport	/home/xsw/svr_base_event/project/threads.h	/^    enum network_transport     transport;$/;"	m	struct:conn_queue_item	typeref:enum:conn_queue_item::network_transport	access:public
conn_queue_item_modes	/home/xsw/svr_base_event/project/threads.h	/^enum conn_queue_item_modes {$/;"	g
conn_read	/home/xsw/svr_base_event/project/net_model.h	/^    conn_read,       \/**< reading in a command line *\/$/;"	e	enum:conn_states
conn_states	/home/xsw/svr_base_event/project/net_model.h	/^enum conn_states {$/;"	g
conn_swallow	/home/xsw/svr_base_event/project/net_model.h	/^    conn_swallow,    \/**< swallowing unnecessary bytes w\/o storing *\/$/;"	e	enum:conn_states
conn_waiting	/home/xsw/svr_base_event/project/net_model.h	/^    conn_waiting,    \/**< waiting for a readable socket *\/$/;"	e	enum:conn_states
conn_watch	/home/xsw/svr_base_event/project/net_model.h	/^    conn_watch,      \/**< held by the logger thread as a watcher *\/$/;"	e	enum:conn_states
conn_write	/home/xsw/svr_base_event/project/net_model.h	/^    conn_write,      \/**< writing out a simple response *\/$/;"	e	enum:conn_states
cq_init	/home/xsw/svr_base_event/project/threads.c	/^static void cq_init(CQ *cq) {$/;"	f	file:	signature:(CQ *cq)
cq_pop	/home/xsw/svr_base_event/project/threads.c	/^static CQ_ITEM *cq_pop(CQ *cq) {$/;"	f	file:	signature:(CQ *cq)
cq_push	/home/xsw/svr_base_event/project/threads.c	/^static void cq_push(CQ *cq, CQ_ITEM *item) {$/;"	f	file:	signature:(CQ *cq, CQ_ITEM *item)
cqi_free	/home/xsw/svr_base_event/project/threads.c	/^static void cqi_free(CQ_ITEM *item) {$/;"	f	file:	signature:(CQ_ITEM *item)
cqi_new	/home/xsw/svr_base_event/project/threads.c	/^static CQ_ITEM *cqi_new(void) {$/;"	f	file:	signature:(void)
crawls_persleep	/home/xsw/svr_base_event/project/net_model.h	/^    int crawls_persleep; \/* Number of LRU crawls to run before sleeping *\/$/;"	m	struct:settings	access:public
create_worker	/home/xsw/svr_base_event/project/threads.c	/^static void create_worker(void *(*func)(void *), void *arg) {$/;"	f	file:	signature:(void *(*func)(void *), void *arg)
detail_enabled	/home/xsw/svr_base_event/project/net_model.h	/^    int detail_enabled;     \/* nonzero if we're collecting detailed stats *\/$/;"	m	struct:settings	access:public
dispatch_conn_new	/home/xsw/svr_base_event/project/threads.c	/^void dispatch_conn_new(int sfd, enum conn_states init_state, int event_flags,$/;"	f	signature:(int sfd, enum conn_states init_state, int event_flags, int read_buffer_size, enum network_transport transport)
do_accept	/home/xsw/svr_base_event/project/net_svr.c	/^void do_accept(evutil_socket_t listener, short event, void *arg)  $/;"	f	signature:(evutil_socket_t listener, short event, void *arg)
do_accept_new_conns	/home/xsw/svr_base_event/project/net_model.c	/^void do_accept_new_conns(const bool do_accept) {$/;"	f	signature:(const bool do_accept)
do_accept_new_conns	/home/xsw/svr_base_event/project/net_model.h	/^void do_accept_new_conns(const bool do_accept);$/;"	p	signature:(const bool do_accept)
do_read	/home/xsw/svr_base_event/project/net_svr.c	/^void do_read(evutil_socket_t fd, short events, void *arg)  $/;"	f	signature:(evutil_socket_t fd, short events, void *arg)
do_read	/home/xsw/svr_base_event/project/net_svr.c	/^void do_read(evutil_socket_t fd, short events, void *arg);  $/;"	p	file:	signature:(evutil_socket_t fd, short events, void *arg)
do_write	/home/xsw/svr_base_event/project/net_svr.c	/^void do_write(evutil_socket_t fd, short events, void *arg)  $/;"	f	signature:(evutil_socket_t fd, short events, void *arg)
do_write	/home/xsw/svr_base_event/project/net_svr.c	/^void do_write(evutil_socket_t fd, short events, void *arg);  $/;"	p	file:	signature:(evutil_socket_t fd, short events, void *arg)
drive_machine	/home/xsw/svr_base_event/project/net_model.c	/^static void drive_machine(conn *c) {$/;"	f	file:	signature:(conn *c)
drop_privileges	/home/xsw/svr_base_event/project/net_model.h	/^    bool drop_privileges;   \/* Whether or not to drop unnecessary process privileges *\/$/;"	m	struct:settings	access:public
dump_enabled	/home/xsw/svr_base_event/project/net_model.h	/^    bool dump_enabled;      \/* whether cachedump\/metadump commands work *\/$/;"	m	struct:settings	access:public
ev_flags	/home/xsw/svr_base_event/project/net_model.h	/^    short  ev_flags;$/;"	m	struct:conn	access:public
event	/home/xsw/svr_base_event/project/net_model.h	/^    struct event event;$/;"	m	struct:conn	typeref:struct:conn::event	access:public
event_flags	/home/xsw/svr_base_event/project/threads.h	/^    int               event_flags;$/;"	m	struct:conn_queue_item	access:public
event_handler	/home/xsw/svr_base_event/project/net_model.c	/^void event_handler(const int fd, const short which, void *arg) {$/;"	f	signature:(const int fd, const short which, void *arg)
evict_to_free	/home/xsw/svr_base_event/project/net_model.h	/^    int evict_to_free;$/;"	m	struct:settings	access:public
ext_compact_under	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_compact_under; \/* when fewer than this many pages, compact *\/$/;"	m	struct:settings	access:public
ext_drop_under	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_drop_under; \/* when fewer than this many pages, drop COLD items *\/$/;"	m	struct:settings	access:public
ext_drop_unread	/home/xsw/svr_base_event/project/net_model.h	/^    bool ext_drop_unread; \/* skip unread items during compaction *\/$/;"	m	struct:settings	access:public
ext_free_memchunks	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_free_memchunks[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:settings	access:public
ext_item_age	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_item_age; \/* max age of tail item before storing ext. *\/$/;"	m	struct:settings	access:public
ext_item_size	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_item_size; \/* minimum size of items to store externally *\/$/;"	m	struct:settings	access:public
ext_low_ttl	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_low_ttl; \/* remaining TTL below this uses own pages *\/$/;"	m	struct:settings	access:public
ext_max_frag	/home/xsw/svr_base_event/project/net_model.h	/^    double ext_max_frag; \/* ideal maximum page fragmentation *\/$/;"	m	struct:settings	access:public
ext_recache_rate	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_recache_rate; \/* counter++ % recache_rate == 0 > recache *\/$/;"	m	struct:settings	access:public
ext_wbuf_size	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_wbuf_size; \/* read only note for the engine *\/$/;"	m	struct:settings	access:public
factor	/home/xsw/svr_base_event/project/net_model.h	/^    double factor;          \/* chunk size growth factor *\/$/;"	m	struct:settings	access:public
fd_state	/home/xsw/svr_base_event/project/net_svr.c	/^struct fd_state {  $/;"	s	file:
fd_state::buffer	/home/xsw/svr_base_event/project/net_svr.c	/^    char buffer[MAX_LINE];  $/;"	m	struct:fd_state	file:	access:public
fd_state::buffer_used	/home/xsw/svr_base_event/project/net_svr.c	/^    size_t buffer_used;  $/;"	m	struct:fd_state	file:	access:public
fd_state::n_written	/home/xsw/svr_base_event/project/net_svr.c	/^    size_t n_written;  $/;"	m	struct:fd_state	file:	access:public
fd_state::read_event	/home/xsw/svr_base_event/project/net_svr.c	/^    struct event *read_event;  $/;"	m	struct:fd_state	typeref:struct:fd_state::event	file:	access:public
fd_state::write_event	/home/xsw/svr_base_event/project/net_svr.c	/^    struct event *write_event;  $/;"	m	struct:fd_state	typeref:struct:fd_state::event	file:	access:public
fd_state::write_upto	/home/xsw/svr_base_event/project/net_svr.c	/^    size_t write_upto;  $/;"	m	struct:fd_state	file:	access:public
flush_enabled	/home/xsw/svr_base_event/project/net_model.h	/^    bool flush_enabled;     \/* flush_all enabled *\/$/;"	m	struct:settings	access:public
free_fd_state	/home/xsw/svr_base_event/project/net_svr.c	/^void free_fd_state(struct fd_state *state)  $/;"	f	signature:(struct fd_state *state)
hash_algorithm	/home/xsw/svr_base_event/project/net_model.h	/^    char *hash_algorithm;     \/* Hash algorithm in use *\/$/;"	m	struct:settings	access:public
hashpower_init	/home/xsw/svr_base_event/project/net_model.h	/^    int hashpower_init;     \/* Starting hash power level *\/$/;"	m	struct:settings	access:public
hdrbuf	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned char *hdrbuf; \/* udp packet headers *\/$/;"	m	struct:conn	access:public
hdrsize	/home/xsw/svr_base_event/project/net_model.h	/^    int    hdrsize;   \/* number of headers' worth of space is allocated *\/$/;"	m	struct:conn	access:public
head	/home/xsw/svr_base_event/project/threads.h	/^    CQ_ITEM *head;$/;"	m	struct:conn_queue	access:public
hot_lru_pct	/home/xsw/svr_base_event/project/net_model.h	/^    int hot_lru_pct; \/* percentage of slab space for HOT_LRU *\/$/;"	m	struct:settings	access:public
hot_max_factor	/home/xsw/svr_base_event/project/net_model.h	/^    double hot_max_factor; \/* HOT tail age relative to COLD tail *\/$/;"	m	struct:settings	access:public
icurr	/home/xsw/svr_base_event/project/net_model.h	/^    item   **icurr;$/;"	m	struct:conn	access:public
idle_timeout	/home/xsw/svr_base_event/project/net_model.h	/^    int idle_timeout;       \/* Number of seconds to let connections idle *\/$/;"	m	struct:settings	access:public
ileft	/home/xsw/svr_base_event/project/net_model.h	/^    int    ileft;$/;"	m	struct:conn	access:public
ilist	/home/xsw/svr_base_event/project/net_model.h	/^    item   **ilist;   \/* list of items to write out *\/$/;"	m	struct:conn	access:public
init_cond	/home/xsw/svr_base_event/project/threads.c	/^static pthread_cond_t init_cond;$/;"	v	file:
init_count	/home/xsw/svr_base_event/project/threads.c	/^static int init_count = 0;$/;"	v	file:
init_lock	/home/xsw/svr_base_event/project/threads.c	/^static pthread_mutex_t init_lock;$/;"	v	file:
init_state	/home/xsw/svr_base_event/project/threads.h	/^    enum conn_states  init_state;$/;"	m	struct:conn_queue_item	typeref:enum:conn_queue_item::conn_states	access:public
inline_ascii_response	/home/xsw/svr_base_event/project/net_model.h	/^    bool inline_ascii_response; \/* pre-format the VALUE line for ASCII responses *\/$/;"	m	struct:settings	access:public
inter	/home/xsw/svr_base_event/project/net_model.h	/^    char *inter;$/;"	m	struct:settings	access:public
io_cache	/home/xsw/svr_base_event/project/net_model.h	/^    cache_t *io_cache;          \/* IO objects *\/$/;"	m	struct:__anon1	access:public
io_queued	/home/xsw/svr_base_event/project/net_model.h	/^    bool io_queued; \/* FIXME: debugging flag *\/$/;"	m	struct:conn	access:public
io_wrapleft	/home/xsw/svr_base_event/project/net_model.h	/^    int io_wrapleft;$/;"	m	struct:conn	access:public
io_wraplist	/home/xsw/svr_base_event/project/net_model.h	/^    io_wrap *io_wraplist; \/* linked list of io_wraps *\/$/;"	m	struct:conn	access:public
iov	/home/xsw/svr_base_event/project/net_model.h	/^    struct iovec *iov;$/;"	m	struct:conn	typeref:struct:conn::iovec	access:public
iovsize	/home/xsw/svr_base_event/project/net_model.h	/^    int    iovsize;   \/* number of elements allocated in iov[] *\/$/;"	m	struct:conn	access:public
iovused	/home/xsw/svr_base_event/project/net_model.h	/^    int    iovused;   \/* number of elements used in iov[] *\/$/;"	m	struct:conn	access:public
isize	/home/xsw/svr_base_event/project/net_model.h	/^    int    isize;$/;"	m	struct:conn	access:public
item	/home/xsw/svr_base_event/project/net_model.h	/^    void   *item;     \/* for commands set\/add\/replace  *\/$/;"	m	struct:conn	access:public
item_size_max	/home/xsw/svr_base_event/project/net_model.h	/^    int item_size_max;        \/* Maximum item size *\/$/;"	m	struct:settings	access:public
keylen	/home/xsw/svr_base_event/project/net_model.h	/^    int keylen;$/;"	m	struct:conn	access:public
l	/home/xsw/svr_base_event/project/net_model.h	/^    logger *l;                  \/* logger buffer *\/$/;"	m	struct:__anon1	access:public
last_cmd_time	/home/xsw/svr_base_event/project/net_model.h	/^    rel_time_t last_cmd_time;$/;"	m	struct:conn	access:public
last_thread	/home/xsw/svr_base_event/project/threads.c	/^static int last_thread = -1;$/;"	v	file:
listen_conn	/home/xsw/svr_base_event/project/net_model.c	/^static conn *listen_conn = NULL;$/;"	v	file:
local_transport	/home/xsw/svr_base_event/project/net_model.h	/^    local_transport, \/* Unix sockets*\/$/;"	e	enum:network_transport
lock	/home/xsw/svr_base_event/project/threads.h	/^    pthread_mutex_t lock;$/;"	m	struct:conn_queue	access:public
logger_buf_size	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int logger_buf_size; \/* size of per-thread logger buffer *\/$/;"	m	struct:settings	access:public
logger_watcher_buf_size	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int logger_watcher_buf_size; \/* size of logger's per-watcher buffer *\/$/;"	m	struct:settings	access:public
lru_bump_buf	/home/xsw/svr_base_event/project/net_model.h	/^    void *lru_bump_buf;         \/* async LRU bump buffer *\/$/;"	m	struct:__anon1	access:public
lru_crawler	/home/xsw/svr_base_event/project/net_model.h	/^    bool lru_crawler;        \/* Whether or not to enable the autocrawler thread *\/$/;"	m	struct:settings	access:public
lru_crawler_sleep	/home/xsw/svr_base_event/project/net_model.h	/^    int lru_crawler_sleep;  \/* Microsecond sleep between items *\/$/;"	m	struct:settings	access:public
lru_crawler_tocrawl	/home/xsw/svr_base_event/project/net_model.h	/^    uint32_t lru_crawler_tocrawl; \/* Number of items to crawl per run *\/$/;"	m	struct:settings	access:public
lru_hits	/home/xsw/svr_base_event/project/net_model.h	/^    uint64_t lru_hits[POWER_LARGEST];$/;"	m	struct:thread_stats	access:public
lru_maintainer_thread	/home/xsw/svr_base_event/project/net_model.h	/^    bool lru_maintainer_thread; \/* LRU maintainer background thread *\/$/;"	m	struct:settings	access:public
lru_segmented	/home/xsw/svr_base_event/project/net_model.h	/^    bool lru_segmented;     \/* Use split or flat LRU's *\/$/;"	m	struct:settings	access:public
main	/home/xsw/svr_base_event/project/net_cli.c	/^int main(int argc, char * argv[])$/;"	f	signature:(int argc, char * argv[])
main	/home/xsw/svr_base_event/project/net_model.c	/^int main (int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	/home/xsw/svr_base_event/project/net_svr.c	/^int main(int c, char **v)  $/;"	f	signature:(int c, char **v)
main_base	/home/xsw/svr_base_event/project/net_model.c	/^static struct event_base *main_base;$/;"	v	typeref:struct:event_base	file:
max_fds	/home/xsw/svr_base_event/project/net_model.c	/^static int max_fds;$/;"	v	file:
maxbytes	/home/xsw/svr_base_event/project/net_model.h	/^    size_t maxbytes;$/;"	m	struct:settings	access:public
maxconns	/home/xsw/svr_base_event/project/net_model.h	/^    int maxconns;$/;"	m	struct:settings	access:public
maxconns_fast	/home/xsw/svr_base_event/project/net_model.h	/^    bool maxconns_fast;     \/* Whether or not to early close connections *\/$/;"	m	struct:settings	access:public
maxconns_handler	/home/xsw/svr_base_event/project/net_model.c	/^static void maxconns_handler(const int fd, const short which, void *arg) {$/;"	f	file:	signature:(const int fd, const short which, void *arg)
maxconnsevent	/home/xsw/svr_base_event/project/net_model.c	/^static struct event maxconnsevent;$/;"	v	typeref:struct:event	file:
maximize_sndbuf	/home/xsw/svr_base_event/project/net_model.c	/^static void maximize_sndbuf(const int sfd) {$/;"	f	file:	signature:(const int sfd)
memcached_thread_init	/home/xsw/svr_base_event/project/threads.c	/^void memcached_thread_init(int nthreads, void *arg) {$/;"	f	signature:(int nthreads, void *arg)
memcached_thread_init	/home/xsw/svr_base_event/project/threads.h	/^void memcached_thread_init(int nthreads, void *arg);$/;"	p	signature:(int nthreads, void *arg)
mode	/home/xsw/svr_base_event/project/threads.h	/^    enum conn_queue_item_modes mode;$/;"	m	struct:conn_queue_item	typeref:enum:conn_queue_item::conn_queue_item_modes	access:public
msgbytes	/home/xsw/svr_base_event/project/net_model.h	/^    int    msgbytes;  \/* number of bytes in current msg *\/$/;"	m	struct:conn	access:public
msgcurr	/home/xsw/svr_base_event/project/net_model.h	/^    int    msgcurr;   \/* element in msglist[] being transmitted now *\/$/;"	m	struct:conn	access:public
msglist	/home/xsw/svr_base_event/project/net_model.h	/^    struct msghdr *msglist;$/;"	m	struct:conn	typeref:struct:conn::msghdr	access:public
msgsize	/home/xsw/svr_base_event/project/net_model.h	/^    int    msgsize;   \/* number of elements allocated in msglist[] *\/$/;"	m	struct:conn	access:public
msgused	/home/xsw/svr_base_event/project/net_model.h	/^    int    msgused;   \/* number of elements used in msglist[] *\/$/;"	m	struct:conn	access:public
mutex	/home/xsw/svr_base_event/project/net_model.h	/^    pthread_mutex_t   mutex;$/;"	m	struct:thread_stats	access:public
n_written	/home/xsw/svr_base_event/project/net_svr.c	/^    size_t n_written;  $/;"	m	struct:fd_state	file:	access:public
negotiating_prot	/home/xsw/svr_base_event/project/net_model.h	/^    negotiating_prot \/* Discovering the protocol *\/$/;"	e	enum:protocol
network_transport	/home/xsw/svr_base_event/project/net_model.h	/^enum network_transport {$/;"	g
new_conn_queue	/home/xsw/svr_base_event/project/net_model.h	/^    struct conn_queue *new_conn_queue; \/* queue of new connections to handle *\/$/;"	m	struct:__anon1	typeref:struct:__anon1::conn_queue	access:public
new_socket	/home/xsw/svr_base_event/project/net_model.c	/^static int new_socket(struct addrinfo *ai) {$/;"	f	file:	signature:(struct addrinfo *ai)
new_socket_linux_block	/home/xsw/svr_base_event/project/net_cli.c	/^static int new_socket_linux_block(void)$/;"	f	file:	signature:(void)
new_socket_unix	/home/xsw/svr_base_event/project/net_cli.c	/^static int new_socket_unix(void) {$/;"	f	file:	signature:(void)
new_socket_unix	/home/xsw/svr_base_event/project/net_model.c	/^static int new_socket_unix(void) {$/;"	f	file:	signature:(void)
next	/home/xsw/svr_base_event/project/net_model.h	/^    conn   *next;     \/* Used for generating a list of conn structures *\/$/;"	m	struct:conn	access:public
next	/home/xsw/svr_base_event/project/threads.h	/^    CQ_ITEM          *next;$/;"	m	struct:conn_queue_item	access:public
noreply	/home/xsw/svr_base_event/project/net_model.h	/^    bool   noreply;   \/* True if the reply should not be sent. *\/$/;"	m	struct:conn	access:public
notify_event	/home/xsw/svr_base_event/project/net_model.h	/^    struct event notify_event;  \/* listen event for notify pipe *\/$/;"	m	struct:__anon1	typeref:struct:__anon1::event	access:public
notify_receive_fd	/home/xsw/svr_base_event/project/net_model.h	/^    int notify_receive_fd;      \/* receiving end of notify pipe *\/$/;"	m	struct:__anon1	access:public
notify_send_fd	/home/xsw/svr_base_event/project/net_model.h	/^    int notify_send_fd;         \/* sending end of notify pipe *\/$/;"	m	struct:__anon1	access:public
num_threads	/home/xsw/svr_base_event/project/net_model.h	/^    int num_threads;        \/* number of worker (without dispatcher) libevent threads to run *\/$/;"	m	struct:settings	access:public
num_threads_per_udp	/home/xsw/svr_base_event/project/net_model.h	/^    int num_threads_per_udp; \/* number of worker threads serving each udp socket *\/$/;"	m	struct:settings	access:public
offset	/home/xsw/svr_base_event/project/net_model.h	/^        size_t offset;$/;"	m	struct:conn::__anon2	access:public
oldest_cas	/home/xsw/svr_base_event/project/net_model.h	/^    uint64_t oldest_cas; \/* ignore existing items with CAS values lower than this *\/$/;"	m	struct:settings	access:public
oldest_live	/home/xsw/svr_base_event/project/net_model.h	/^    rel_time_t oldest_live; \/* ignore existing items older than this *\/$/;"	m	struct:settings	access:public
opaque	/home/xsw/svr_base_event/project/net_model.h	/^    int opaque;$/;"	m	struct:conn	access:public
pause_thread_types	/home/xsw/svr_base_event/project/net_model.h	/^enum pause_thread_types {$/;"	g
port	/home/xsw/svr_base_event/project/net_model.h	/^    int port;$/;"	m	struct:settings	access:public
prefix_delimiter	/home/xsw/svr_base_event/project/net_model.h	/^    char prefix_delimiter;  \/* character that marks a key prefix (for stats) *\/$/;"	m	struct:settings	access:public
protocol	/home/xsw/svr_base_event/project/net_model.h	/^    enum protocol protocol;   \/* which protocol this connection speaks *\/$/;"	m	struct:conn	typeref:enum:conn::protocol	access:public
protocol	/home/xsw/svr_base_event/project/net_model.h	/^enum protocol {$/;"	g
queue_new_conn	/home/xsw/svr_base_event/project/threads.h	/^    queue_new_conn,   \/* brand new connection. *\/$/;"	e	enum:conn_queue_item_modes
queue_redispatch	/home/xsw/svr_base_event/project/threads.h	/^    queue_redispatch, \/* redispatching from side thread *\/$/;"	e	enum:conn_queue_item_modes
rbuf	/home/xsw/svr_base_event/project/net_model.h	/^    char   *rbuf;   \/** buffer to read commands into *\/$/;"	m	struct:conn	access:public
rbytes	/home/xsw/svr_base_event/project/net_model.h	/^    int    rbytes;  \/** how much data, starting from rcur, do we have unparsed *\/$/;"	m	struct:conn	access:public
rcurr	/home/xsw/svr_base_event/project/net_model.h	/^    char   *rcurr;  \/** but if we parsed some already, this is where we stopped *\/$/;"	m	struct:conn	access:public
read_buffer_size	/home/xsw/svr_base_event/project/threads.h	/^    int               read_buffer_size;$/;"	m	struct:conn_queue_item	access:public
read_event	/home/xsw/svr_base_event/project/net_svr.c	/^    struct event *read_event;  $/;"	m	struct:fd_state	typeref:struct:fd_state::event	file:	access:public
recache_counter	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int recache_counter;$/;"	m	struct:conn	access:public
redispatch_conn	/home/xsw/svr_base_event/project/threads.c	/^void redispatch_conn(conn *c) {$/;"	f	signature:(conn *c)
register_thread_initialized	/home/xsw/svr_base_event/project/threads.c	/^static void register_thread_initialized(void) {$/;"	f	file:	signature:(void)
rel_time_t	/home/xsw/svr_base_event/project/net_model.h	/^typedef unsigned int rel_time_t;$/;"	t
relaxed_privileges	/home/xsw/svr_base_event/project/net_model.h	/^    bool relaxed_privileges;   \/* Relax process restrictions when running testapp *\/$/;"	m	struct:settings	access:public
reqs_per_event	/home/xsw/svr_base_event/project/net_model.h	/^    int reqs_per_event;     \/* Maximum number of io to process on each$/;"	m	struct:settings	access:public
request_addr	/home/xsw/svr_base_event/project/net_model.h	/^    struct sockaddr_in6 request_addr; \/* udp: Who sent the most recent request *\/$/;"	m	struct:conn	typeref:struct:conn::sockaddr_in6	access:public
request_addr_size	/home/xsw/svr_base_event/project/net_model.h	/^    socklen_t request_addr_size;$/;"	m	struct:conn	access:public
request_id	/home/xsw/svr_base_event/project/net_model.h	/^    int    request_id; \/* Incoming UDP request ID, if this is a UDP "connection" *\/$/;"	m	struct:conn	access:public
ritem	/home/xsw/svr_base_event/project/net_model.h	/^    char   *ritem;  \/** when we read in an item's value, it goes here *\/$/;"	m	struct:conn	access:public
rlbytes	/home/xsw/svr_base_event/project/net_model.h	/^    int    rlbytes;$/;"	m	struct:conn	access:public
rot13_char	/home/xsw/svr_base_event/project/net_svr.c	/^char rot13_char(char c)  $/;"	f	signature:(char c)
rsize	/home/xsw/svr_base_event/project/net_model.h	/^    int    rsize;   \/** total allocated size of rbuf *\/$/;"	m	struct:conn	access:public
run	/home/xsw/svr_base_event/project/net_cli.c	/^void run(char * buf, int len)$/;"	f	signature:(char * buf, int len)
run	/home/xsw/svr_base_event/project/net_svr.c	/^void run(void)  $/;"	f	signature:(void)
sasl	/home/xsw/svr_base_event/project/net_model.h	/^    bool sasl;              \/* SASL on\/off *\/$/;"	m	struct:settings	access:public
sasl_conn	/home/xsw/svr_base_event/project/net_model.h	/^    sasl_conn_t *sasl_conn;$/;"	m	struct:conn	access:public
sasl_started	/home/xsw/svr_base_event/project/net_model.h	/^    bool sasl_started;$/;"	m	struct:conn	access:public
sbytes	/home/xsw/svr_base_event/project/net_model.h	/^    int    sbytes;    \/* how many bytes to swallow *\/$/;"	m	struct:conn	access:public
server_socket	/home/xsw/svr_base_event/project/net_model.c	/^static int server_socket(const char *interface,$/;"	f	file:	signature:(const char *interface, int port, enum network_transport transport, FILE *portnumber_file)
server_socket_unix	/home/xsw/svr_base_event/project/net_model.c	/^static int server_socket_unix(const char *path, int access_mask) {$/;"	f	file:	signature:(const char *path, int access_mask)
server_sockets	/home/xsw/svr_base_event/project/net_model.c	/^static int server_sockets(int port, enum network_transport transport,$/;"	f	file:	signature:(int port, enum network_transport transport, FILE *portnumber_file)
settings	/home/xsw/svr_base_event/project/net_model.h	/^struct settings {$/;"	s
settings::access	/home/xsw/svr_base_event/project/net_model.h	/^    int access;  \/* access mask (a la chmod) for unix domain socket *\/$/;"	m	struct:settings	access:public
settings::backlog	/home/xsw/svr_base_event/project/net_model.h	/^    int backlog;$/;"	m	struct:settings	access:public
settings::binding_protocol	/home/xsw/svr_base_event/project/net_model.h	/^    enum protocol binding_protocol;$/;"	m	struct:settings	typeref:enum:settings::protocol	access:public
settings::chunk_size	/home/xsw/svr_base_event/project/net_model.h	/^    int chunk_size;$/;"	m	struct:settings	access:public
settings::crawls_persleep	/home/xsw/svr_base_event/project/net_model.h	/^    int crawls_persleep; \/* Number of LRU crawls to run before sleeping *\/$/;"	m	struct:settings	access:public
settings::detail_enabled	/home/xsw/svr_base_event/project/net_model.h	/^    int detail_enabled;     \/* nonzero if we're collecting detailed stats *\/$/;"	m	struct:settings	access:public
settings::drop_privileges	/home/xsw/svr_base_event/project/net_model.h	/^    bool drop_privileges;   \/* Whether or not to drop unnecessary process privileges *\/$/;"	m	struct:settings	access:public
settings::dump_enabled	/home/xsw/svr_base_event/project/net_model.h	/^    bool dump_enabled;      \/* whether cachedump\/metadump commands work *\/$/;"	m	struct:settings	access:public
settings::evict_to_free	/home/xsw/svr_base_event/project/net_model.h	/^    int evict_to_free;$/;"	m	struct:settings	access:public
settings::ext_compact_under	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_compact_under; \/* when fewer than this many pages, compact *\/$/;"	m	struct:settings	access:public
settings::ext_drop_under	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_drop_under; \/* when fewer than this many pages, drop COLD items *\/$/;"	m	struct:settings	access:public
settings::ext_drop_unread	/home/xsw/svr_base_event/project/net_model.h	/^    bool ext_drop_unread; \/* skip unread items during compaction *\/$/;"	m	struct:settings	access:public
settings::ext_free_memchunks	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_free_memchunks[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:settings	access:public
settings::ext_item_age	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_item_age; \/* max age of tail item before storing ext. *\/$/;"	m	struct:settings	access:public
settings::ext_item_size	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_item_size; \/* minimum size of items to store externally *\/$/;"	m	struct:settings	access:public
settings::ext_low_ttl	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_low_ttl; \/* remaining TTL below this uses own pages *\/$/;"	m	struct:settings	access:public
settings::ext_max_frag	/home/xsw/svr_base_event/project/net_model.h	/^    double ext_max_frag; \/* ideal maximum page fragmentation *\/$/;"	m	struct:settings	access:public
settings::ext_recache_rate	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_recache_rate; \/* counter++ % recache_rate == 0 > recache *\/$/;"	m	struct:settings	access:public
settings::ext_wbuf_size	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int ext_wbuf_size; \/* read only note for the engine *\/$/;"	m	struct:settings	access:public
settings::factor	/home/xsw/svr_base_event/project/net_model.h	/^    double factor;          \/* chunk size growth factor *\/$/;"	m	struct:settings	access:public
settings::flush_enabled	/home/xsw/svr_base_event/project/net_model.h	/^    bool flush_enabled;     \/* flush_all enabled *\/$/;"	m	struct:settings	access:public
settings::hash_algorithm	/home/xsw/svr_base_event/project/net_model.h	/^    char *hash_algorithm;     \/* Hash algorithm in use *\/$/;"	m	struct:settings	access:public
settings::hashpower_init	/home/xsw/svr_base_event/project/net_model.h	/^    int hashpower_init;     \/* Starting hash power level *\/$/;"	m	struct:settings	access:public
settings::hot_lru_pct	/home/xsw/svr_base_event/project/net_model.h	/^    int hot_lru_pct; \/* percentage of slab space for HOT_LRU *\/$/;"	m	struct:settings	access:public
settings::hot_max_factor	/home/xsw/svr_base_event/project/net_model.h	/^    double hot_max_factor; \/* HOT tail age relative to COLD tail *\/$/;"	m	struct:settings	access:public
settings::idle_timeout	/home/xsw/svr_base_event/project/net_model.h	/^    int idle_timeout;       \/* Number of seconds to let connections idle *\/$/;"	m	struct:settings	access:public
settings::inline_ascii_response	/home/xsw/svr_base_event/project/net_model.h	/^    bool inline_ascii_response; \/* pre-format the VALUE line for ASCII responses *\/$/;"	m	struct:settings	access:public
settings::inter	/home/xsw/svr_base_event/project/net_model.h	/^    char *inter;$/;"	m	struct:settings	access:public
settings::item_size_max	/home/xsw/svr_base_event/project/net_model.h	/^    int item_size_max;        \/* Maximum item size *\/$/;"	m	struct:settings	access:public
settings::logger_buf_size	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int logger_buf_size; \/* size of per-thread logger buffer *\/$/;"	m	struct:settings	access:public
settings::logger_watcher_buf_size	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int logger_watcher_buf_size; \/* size of logger's per-watcher buffer *\/$/;"	m	struct:settings	access:public
settings::lru_crawler	/home/xsw/svr_base_event/project/net_model.h	/^    bool lru_crawler;        \/* Whether or not to enable the autocrawler thread *\/$/;"	m	struct:settings	access:public
settings::lru_crawler_sleep	/home/xsw/svr_base_event/project/net_model.h	/^    int lru_crawler_sleep;  \/* Microsecond sleep between items *\/$/;"	m	struct:settings	access:public
settings::lru_crawler_tocrawl	/home/xsw/svr_base_event/project/net_model.h	/^    uint32_t lru_crawler_tocrawl; \/* Number of items to crawl per run *\/$/;"	m	struct:settings	access:public
settings::lru_maintainer_thread	/home/xsw/svr_base_event/project/net_model.h	/^    bool lru_maintainer_thread; \/* LRU maintainer background thread *\/$/;"	m	struct:settings	access:public
settings::lru_segmented	/home/xsw/svr_base_event/project/net_model.h	/^    bool lru_segmented;     \/* Use split or flat LRU's *\/$/;"	m	struct:settings	access:public
settings::maxbytes	/home/xsw/svr_base_event/project/net_model.h	/^    size_t maxbytes;$/;"	m	struct:settings	access:public
settings::maxconns	/home/xsw/svr_base_event/project/net_model.h	/^    int maxconns;$/;"	m	struct:settings	access:public
settings::maxconns_fast	/home/xsw/svr_base_event/project/net_model.h	/^    bool maxconns_fast;     \/* Whether or not to early close connections *\/$/;"	m	struct:settings	access:public
settings::num_threads	/home/xsw/svr_base_event/project/net_model.h	/^    int num_threads;        \/* number of worker (without dispatcher) libevent threads to run *\/$/;"	m	struct:settings	access:public
settings::num_threads_per_udp	/home/xsw/svr_base_event/project/net_model.h	/^    int num_threads_per_udp; \/* number of worker threads serving each udp socket *\/$/;"	m	struct:settings	access:public
settings::oldest_cas	/home/xsw/svr_base_event/project/net_model.h	/^    uint64_t oldest_cas; \/* ignore existing items with CAS values lower than this *\/$/;"	m	struct:settings	access:public
settings::oldest_live	/home/xsw/svr_base_event/project/net_model.h	/^    rel_time_t oldest_live; \/* ignore existing items older than this *\/$/;"	m	struct:settings	access:public
settings::port	/home/xsw/svr_base_event/project/net_model.h	/^    int port;$/;"	m	struct:settings	access:public
settings::prefix_delimiter	/home/xsw/svr_base_event/project/net_model.h	/^    char prefix_delimiter;  \/* character that marks a key prefix (for stats) *\/$/;"	m	struct:settings	access:public
settings::relaxed_privileges	/home/xsw/svr_base_event/project/net_model.h	/^    bool relaxed_privileges;   \/* Relax process restrictions when running testapp *\/$/;"	m	struct:settings	access:public
settings::reqs_per_event	/home/xsw/svr_base_event/project/net_model.h	/^    int reqs_per_event;     \/* Maximum number of io to process on each$/;"	m	struct:settings	access:public
settings::sasl	/home/xsw/svr_base_event/project/net_model.h	/^    bool sasl;              \/* SASL on\/off *\/$/;"	m	struct:settings	access:public
settings::shutdown_command	/home/xsw/svr_base_event/project/net_model.h	/^    bool shutdown_command; \/* allow shutdown command *\/$/;"	m	struct:settings	access:public
settings::slab_automove	/home/xsw/svr_base_event/project/net_model.h	/^    int slab_automove;     \/* Whether or not to automatically move slabs *\/$/;"	m	struct:settings	access:public
settings::slab_automove_freeratio	/home/xsw/svr_base_event/project/net_model.h	/^    double slab_automove_freeratio; \/* % of memory to hold free as buffer *\/$/;"	m	struct:settings	access:public
settings::slab_automove_ratio	/home/xsw/svr_base_event/project/net_model.h	/^    double slab_automove_ratio; \/* youngest must be within pct of oldest *\/$/;"	m	struct:settings	access:public
settings::slab_automove_window	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int slab_automove_window; \/* window mover for algorithm *\/$/;"	m	struct:settings	access:public
settings::slab_chunk_size_max	/home/xsw/svr_base_event/project/net_model.h	/^    int slab_chunk_size_max;  \/* Upper end for chunks within slab pages. *\/$/;"	m	struct:settings	access:public
settings::slab_page_size	/home/xsw/svr_base_event/project/net_model.h	/^    int slab_page_size;     \/* Slab's page units. *\/$/;"	m	struct:settings	access:public
settings::slab_reassign	/home/xsw/svr_base_event/project/net_model.h	/^    bool slab_reassign;     \/* Whether or not slab reassignment is allowed *\/$/;"	m	struct:settings	access:public
settings::socketpath	/home/xsw/svr_base_event/project/net_model.h	/^    char *socketpath;   \/* path to unix socket if using local socket *\/$/;"	m	struct:settings	access:public
settings::tail_repair_time	/home/xsw/svr_base_event/project/net_model.h	/^    int tail_repair_time;   \/* LRU tail refcount leak repair time *\/$/;"	m	struct:settings	access:public
settings::temp_lru	/home/xsw/svr_base_event/project/net_model.h	/^    bool temp_lru; \/* TTL < temporary_ttl uses TEMP_LRU *\/$/;"	m	struct:settings	access:public
settings::temporary_ttl	/home/xsw/svr_base_event/project/net_model.h	/^    uint32_t temporary_ttl; \/* temporary LRU threshold *\/$/;"	m	struct:settings	access:public
settings::udpport	/home/xsw/svr_base_event/project/net_model.h	/^    int udpport;$/;"	m	struct:settings	access:public
settings::use_cas	/home/xsw/svr_base_event/project/net_model.h	/^    bool use_cas;$/;"	m	struct:settings	access:public
settings::verbose	/home/xsw/svr_base_event/project/net_model.h	/^    int verbose;$/;"	m	struct:settings	access:public
settings::warm_lru_pct	/home/xsw/svr_base_event/project/net_model.h	/^    int warm_lru_pct; \/* percentage of slab space for WARM_LRU *\/$/;"	m	struct:settings	access:public
settings::warm_max_factor	/home/xsw/svr_base_event/project/net_model.h	/^    double warm_max_factor; \/* WARM tail age relative to COLD tail *\/$/;"	m	struct:settings	access:public
settings_init	/home/xsw/svr_base_event/project/net_model.c	/^static void settings_init(void) {$/;"	f	file:	signature:(void)
setup_thread	/home/xsw/svr_base_event/project/threads.c	/^static void setup_thread(LIBEVENT_THREAD *me) {$/;"	f	file:	signature:(LIBEVENT_THREAD *me)
sfd	/home/xsw/svr_base_event/project/net_model.h	/^    int    sfd;$/;"	m	struct:conn	access:public
sfd	/home/xsw/svr_base_event/project/threads.h	/^    int               sfd;$/;"	m	struct:conn_queue_item	access:public
shutdown_command	/home/xsw/svr_base_event/project/net_model.h	/^    bool shutdown_command; \/* allow shutdown command *\/$/;"	m	struct:settings	access:public
sidethread_conn_close	/home/xsw/svr_base_event/project/threads.c	/^void sidethread_conn_close(conn *c) {$/;"	f	signature:(conn *c)
size	/home/xsw/svr_base_event/project/net_model.h	/^        size_t size;$/;"	m	struct:conn::__anon2	access:public
slab_automove	/home/xsw/svr_base_event/project/net_model.h	/^    int slab_automove;     \/* Whether or not to automatically move slabs *\/$/;"	m	struct:settings	access:public
slab_automove_freeratio	/home/xsw/svr_base_event/project/net_model.h	/^    double slab_automove_freeratio; \/* % of memory to hold free as buffer *\/$/;"	m	struct:settings	access:public
slab_automove_ratio	/home/xsw/svr_base_event/project/net_model.h	/^    double slab_automove_ratio; \/* youngest must be within pct of oldest *\/$/;"	m	struct:settings	access:public
slab_automove_window	/home/xsw/svr_base_event/project/net_model.h	/^    unsigned int slab_automove_window; \/* window mover for algorithm *\/$/;"	m	struct:settings	access:public
slab_chunk_size_max	/home/xsw/svr_base_event/project/net_model.h	/^    int slab_chunk_size_max;  \/* Upper end for chunks within slab pages. *\/$/;"	m	struct:settings	access:public
slab_page_size	/home/xsw/svr_base_event/project/net_model.h	/^    int slab_page_size;     \/* Slab's page units. *\/$/;"	m	struct:settings	access:public
slab_reassign	/home/xsw/svr_base_event/project/net_model.h	/^    bool slab_reassign;     \/* Whether or not slab reassignment is allowed *\/$/;"	m	struct:settings	access:public
slab_stats	/home/xsw/svr_base_event/project/net_model.h	/^    struct slab_stats slab_stats[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:thread_stats	typeref:struct:thread_stats::slab_stats	access:public
slab_stats	/home/xsw/svr_base_event/project/net_model.h	/^struct slab_stats {$/;"	s
socketpath	/home/xsw/svr_base_event/project/net_model.h	/^    char *socketpath;   \/* path to unix socket if using local socket *\/$/;"	m	struct:settings	access:public
state	/home/xsw/svr_base_event/project/net_model.h	/^    enum conn_states  state;$/;"	m	struct:conn	typeref:enum:conn::conn_states	access:public
stats	/home/xsw/svr_base_event/project/net_model.h	/^    struct thread_stats stats;  \/* Stats generated by this thread *\/$/;"	m	struct:__anon1	typeref:struct:__anon1::thread_stats	access:public
stats	/home/xsw/svr_base_event/project/net_model.h	/^    } stats;$/;"	m	struct:conn	typeref:struct:conn::__anon2	access:public
storage	/home/xsw/svr_base_event/project/net_model.h	/^    void *storage;              \/* data object for storage system *\/$/;"	m	struct:__anon1	access:public
substate	/home/xsw/svr_base_event/project/net_model.h	/^    enum bin_substates substate;$/;"	m	struct:conn	typeref:enum:conn::bin_substates	access:public
suffix_cache	/home/xsw/svr_base_event/project/net_model.h	/^    cache_t *suffix_cache;      \/* suffix cache *\/$/;"	m	struct:__anon1	access:public
suffixcurr	/home/xsw/svr_base_event/project/net_model.h	/^    char   **suffixcurr;$/;"	m	struct:conn	access:public
suffixleft	/home/xsw/svr_base_event/project/net_model.h	/^    int    suffixleft;$/;"	m	struct:conn	access:public
suffixlist	/home/xsw/svr_base_event/project/net_model.h	/^    char   **suffixlist;$/;"	m	struct:conn	access:public
suffixsize	/home/xsw/svr_base_event/project/net_model.h	/^    int    suffixsize;$/;"	m	struct:conn	access:public
tail	/home/xsw/svr_base_event/project/threads.h	/^    CQ_ITEM *tail;$/;"	m	struct:conn_queue	access:public
tail_repair_time	/home/xsw/svr_base_event/project/net_model.h	/^    int tail_repair_time;   \/* LRU tail refcount leak repair time *\/$/;"	m	struct:settings	access:public
tcp_transport	/home/xsw/svr_base_event/project/net_model.h	/^    tcp_transport,$/;"	e	enum:network_transport
temp_lru	/home/xsw/svr_base_event/project/net_model.h	/^    bool temp_lru; \/* TTL < temporary_ttl uses TEMP_LRU *\/$/;"	m	struct:settings	access:public
temporary_ttl	/home/xsw/svr_base_event/project/net_model.h	/^    uint32_t temporary_ttl; \/* temporary LRU threshold *\/$/;"	m	struct:settings	access:public
test_change_vim	/home/xsw/svr_base_event/project/net_cli.c	/^void test_change_vim()$/;"	f
thread	/home/xsw/svr_base_event/project/net_model.h	/^    LIBEVENT_THREAD *thread; \/* Pointer to the thread object serving this connection *\/$/;"	m	struct:conn	access:public
thread_id	/home/xsw/svr_base_event/project/net_model.h	/^    pthread_t thread_id;        \/* unique ID of this thread *\/$/;"	m	struct:__anon1	access:public
thread_libevent_process	/home/xsw/svr_base_event/project/threads.c	/^static void thread_libevent_process(int fd, short which, void *arg) {$/;"	f	file:	signature:(int fd, short which, void *arg)
thread_libevent_process	/home/xsw/svr_base_event/project/threads.c	/^static void thread_libevent_process(int fd, short which, void *arg);$/;"	p	file:	signature:(int fd, short which, void *arg)
thread_stats	/home/xsw/svr_base_event/project/net_model.h	/^struct thread_stats {$/;"	s
thread_stats::lru_hits	/home/xsw/svr_base_event/project/net_model.h	/^    uint64_t lru_hits[POWER_LARGEST];$/;"	m	struct:thread_stats	access:public
thread_stats::mutex	/home/xsw/svr_base_event/project/net_model.h	/^    pthread_mutex_t   mutex;$/;"	m	struct:thread_stats	access:public
thread_stats::slab_stats	/home/xsw/svr_base_event/project/net_model.h	/^    struct slab_stats slab_stats[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:thread_stats	typeref:struct:thread_stats::slab_stats	access:public
transport	/home/xsw/svr_base_event/project/net_model.h	/^    enum network_transport transport; \/* what transport is used by this connection *\/$/;"	m	struct:conn	typeref:enum:conn::network_transport	access:public
transport	/home/xsw/svr_base_event/project/threads.h	/^    enum network_transport     transport;$/;"	m	struct:conn_queue_item	typeref:enum:conn_queue_item::network_transport	access:public
try_read_result	/home/xsw/svr_base_event/project/net_model.c	/^enum try_read_result {$/;"	g	file:
udp_transport	/home/xsw/svr_base_event/project/net_model.h	/^    udp_transport$/;"	e	enum:network_transport
udpport	/home/xsw/svr_base_event/project/net_model.h	/^    int udpport;$/;"	m	struct:settings	access:public
update_event	/home/xsw/svr_base_event/project/net_model.c	/^static bool update_event(conn *c, const int new_flags) {$/;"	f	file:	signature:(conn *c, const int new_flags)
use_cas	/home/xsw/svr_base_event/project/net_model.h	/^    bool use_cas;$/;"	m	struct:settings	access:public
verbose	/home/xsw/svr_base_event/project/net_model.h	/^    int verbose;$/;"	m	struct:settings	access:public
wait_for_thread_registration	/home/xsw/svr_base_event/project/threads.c	/^static void wait_for_thread_registration(int nthreads) {$/;"	f	file:	signature:(int nthreads)
warm_lru_pct	/home/xsw/svr_base_event/project/net_model.h	/^    int warm_lru_pct; \/* percentage of slab space for WARM_LRU *\/$/;"	m	struct:settings	access:public
warm_max_factor	/home/xsw/svr_base_event/project/net_model.h	/^    double warm_max_factor; \/* WARM tail age relative to COLD tail *\/$/;"	m	struct:settings	access:public
wbuf	/home/xsw/svr_base_event/project/net_model.h	/^    char   *wbuf;$/;"	m	struct:conn	access:public
wbytes	/home/xsw/svr_base_event/project/net_model.h	/^    int    wbytes;$/;"	m	struct:conn	access:public
wcurr	/home/xsw/svr_base_event/project/net_model.h	/^    char   *wcurr;$/;"	m	struct:conn	access:public
which	/home/xsw/svr_base_event/project/net_model.h	/^    short  which;   \/** which events were just triggered *\/$/;"	m	struct:conn	access:public
worker_libevent	/home/xsw/svr_base_event/project/threads.c	/^static void *worker_libevent(void *arg) {$/;"	f	file:	signature:(void *arg)
write_and_free	/home/xsw/svr_base_event/project/net_model.h	/^    void   *write_and_free; \/** free this memory after finishing writing *\/$/;"	m	struct:conn	access:public
write_and_go	/home/xsw/svr_base_event/project/net_model.h	/^    enum conn_states  write_and_go;$/;"	m	struct:conn	typeref:enum:conn::conn_states	access:public
write_event	/home/xsw/svr_base_event/project/net_svr.c	/^    struct event *write_event;  $/;"	m	struct:fd_state	typeref:struct:fd_state::event	file:	access:public
write_upto	/home/xsw/svr_base_event/project/net_svr.c	/^    size_t write_upto;  $/;"	m	struct:fd_state	file:	access:public
wsize	/home/xsw/svr_base_event/project/net_model.h	/^    int    wsize;$/;"	m	struct:conn	access:public
